## Multi-paradigm programming

- Theory
  - ğŸ“ Procedural programming 
  - ğŸ“ Imperative programming
  - ğŸ“ Structured programming
  - ğŸ“ Non-structured programming
  - ğŸ“ Functional programming
  - ğŸ“ Prototype-based programming
  - ğŸ”¬ Object-oriented programming
  - ğŸ”¬ Object-based programming
  - ğŸ“ Generic programming
  - ğŸ“ Concurrent computing
  - ğŸ“ Asyncronous programming
  - ğŸ‘‚ Parallel programming
  - ğŸ‘‚ Reactive programming
  - ğŸ‘‚ FRP (Functional-reactive)
  - ğŸ‘‚ Automata-based programming
  - ğŸ‘‚ Domain-specific languages
  - ğŸ“ Multi-paradigm programming
  - ğŸ“ Metaprogramming
  - ğŸ‘‚ Actor model
- OOP basics
  - ğŸš€ constructor
  - ğŸš€ new
  - ğŸš€ Static method
  - ğŸš€ Method
  - ğŸ“ Async method
  - ğŸš€ Getters, Setters
  - ğŸš€ Public fields
  - ğŸš€ Private fields
  - ğŸš€ Field declarations
  - ğŸš€ Inheritance
  - ğŸš€ Parent class
  - ğŸš€ Polymorphism
  - ğŸš€ Abstract class
  - ğŸš€ Interface
  - ğŸš€ Encapsulation
  - ğŸ”¬ Hidden class
  - ğŸš€ Object form
  - ğŸš€ instance
  - ğŸš€ Introspection
  - ğŸš€ Reflection
- Patterns
  - ğŸš€ Singleton
  - ğŸš€ Factory Method
  - ğŸš€ Abstract Factory
  - ğŸ‘‚ Adapter
  - ğŸ‘‚ Observer
  - ğŸ‘‚ Strategy
  - ğŸ‘‚ Facade
  - ğŸ‘‚ Proxy
  - ğŸ‘‚ Chain of Responsibility
  - ğŸ–ï¸ Command
  - ğŸ‘‚ Iterator
  - ğŸ‘‚ State
  - ğŸ‘‚ Bridge
  - ğŸ‘‚ Builder
  - ğŸ‘‚ Prototype
  - ğŸ‘‚ Composite
  - ğŸ‘‚ Decorator
  - ğŸ‘‚ Flyweight
  - ğŸ‘‚ Mediator
  - ğŸ‘‚ Memento
  - ğŸ‘‚ Template Method
  - ğŸ‘‚ Visitor
